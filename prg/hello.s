;
; File generated by cc65 v 2.16 - Git e67bbcb
;
	.fopt		compiler,"cc65 v 2.16 - Git e67bbcb"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_rand
	.import		_pal_bg
	.import		_ppu_wait_nmi
	.import		_ppu_on_all
	.import		_pad_poll
	.export		_i
	.export		_j
	.export		_ppu_addr
	.export		_ppu_data
	.export		_ppu_data_size
	.export		_pad
	.export		_player_rect
	.export		_stick_rect
	.export		_colliding
	.export		_points
	.export		_player
	.export		_stick
	.export		_PALETTE
	.export		_ppu_scroll_reset
	.export		_ppu_write
	.export		_ppu_disable
	.export		_ppu_enable
	.export		_draw_background
	.export		_init
	.export		_update
	.export		_main

.segment	"RODATA"

_PALETTE:
	.byte	$0F
	.byte	$12
	.byte	$20
	.byte	$16
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$0F
	.byte	$16
	.byte	$28
	.byte	$12
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00

.segment	"BSS"

.segment	"ZEROPAGE"
_i:
	.res	1,$00
_j:
	.res	1,$00
_ppu_addr:
	.res	2,$00
_ppu_data:
	.res	2,$00
_ppu_data_size:
	.res	1,$00
_pad:
	.res	1,$00
_player_rect:
	.res	6,$00
_stick_rect:
	.res	6,$00
_colliding:
	.res	1,$00
_points:
	.res	3,$00
.segment	"BSS"
_player:
	.res	4,$00
_stick:
	.res	4,$00

; ---------------------------------------------------------------
; void __near__ ppu_scroll_reset (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_scroll_reset: near

.segment	"CODE"

;
; PPU_SCROLL = 0x00;
;
	lda     #$00
	sta     $2005
;
; PPU_SCROLL = 0x00;
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_write (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_write: near

.segment	"CODE"

;
; PPU_ADDRESS = (u8) (ppu_addr >> 8);
;
	lda     _ppu_addr+1
	sta     $2006
;
; PPU_ADDRESS = (u8) (ppu_addr);
;
	lda     _ppu_addr
	sta     $2006
;
; for (i = 0; i < ppu_data_size; ++i)
;
	lda     #$00
	sta     _i
L0129:	lda     _i
	cmp     _ppu_data_size
	bcs     L003A
;
; PPU_DATA = ppu_data[i];
;
	lda     _ppu_data
	ldx     _ppu_data+1
	ldy     _i
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     $2007
;
; for (i = 0; i < ppu_data_size; ++i)
;
	inc     _i
	jmp     L0129
;
; }
;
L003A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_disable (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_disable: near

.segment	"CODE"

;
; PPU_CTRL = 0;
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_enable (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_enable: near

.segment	"CODE"

;
; PPUCTRL_NMI_ON      ; /* Enable NMIs */
;
	lda     #$80
	sta     $2000
;
; PPUMASK_L8_SSHOW ;    /* Show sprites in leftmost 8px */
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_background: near

.segment	"CODE"

;
; PPU_ADDRESS = (u8) ((PPU_NAMETABLE_0 + PPU_NAMETABLE_OFFSET) >> 8);
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = (u8) (PPU_NAMETABLE_0 + PPU_NAMETABLE_OFFSET);
;
	sta     $2006
;
; PPU_DATA = BORDER_TL;
;
	lda     #$01
	sta     $2007
;
; for (i = 0; i < (NUM_COLS - 2); ++i)
;
	lda     #$00
	sta     _i
L012A:	lda     _i
	cmp     #$1E
	bcs     L012B
;
; PPU_DATA = BORDER_T;
;
	lda     #$04
	sta     $2007
;
; for (i = 0; i < (NUM_COLS - 2); ++i)
;
	inc     _i
	jmp     L012A
;
; PPU_DATA = BORDER_TR;
;
L012B:	lda     #$02
	sta     $2007
;
; for (i = 0; i < (NUM_ROWS - 2); ++i)
;
	lda     #$00
	sta     _i
L012C:	lda     _i
	cmp     #$1A
	bcs     L012F
;
; PPU_DATA = BORDER_L;
;
	lda     #$03
	sta     $2007
;
; for (j = 0; j < (NUM_COLS - 2); ++j)
;
	lda     #$00
	sta     _j
L012D:	lda     _j
	cmp     #$1E
	bcs     L012E
;
; PPU_DATA = BLANK_TILE;
;
	lda     #$00
	sta     $2007
;
; for (j = 0; j < (NUM_COLS - 2); ++j)
;
	inc     _j
	jmp     L012D
;
; PPU_DATA = BORDER_R;
;
L012E:	lda     #$13
	sta     $2007
;
; for (i = 0; i < (NUM_ROWS - 2); ++i)
;
	inc     _i
	jmp     L012C
;
; PPU_DATA = BORDER_BL;
;
L012F:	lda     #$11
	sta     $2007
;
; for (i = 0; i < (NUM_COLS - 2); ++i)
;
	lda     #$00
	sta     _i
L0130:	lda     _i
	cmp     #$1E
	bcs     L0131
;
; PPU_DATA = BORDER_B;
;
	lda     #$14
	sta     $2007
;
; for (i = 0; i < (NUM_COLS - 2); ++i)
;
	inc     _i
	jmp     L0130
;
; PPU_DATA = BORDER_BR;
;
L0131:	lda     #$12
	sta     $2007
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init: near

.segment	"CODE"

;
; player.x = (MAX_X / 2) - (SPRITE_WIDTH / 2);
;
	lda     #$7C
	sta     _player+3
;
; player.y = (MAX_Y / 2) - (SPRITE_WIDTH / 2);
;
	lda     #$6F
	sta     _player
;
; player.tile_index = SPRITE_PLAYER;
;
	lda     #$10
	sta     _player+1
;
; stick.x = rand() + 32;
;
	jsr     _rand
	clc
	adc     #$20
	sta     _stick+3
;
; stick.y = rand() + 32;
;
	jsr     _rand
	clc
	adc     #$20
	sta     _stick
;
; stick.tile_index = SPRITE_STICK;
;
	lda     #$05
	sta     _stick+1
;
; player_rect.x = player.x;
;
	lda     _player+3
	sta     _player_rect
;
; player_rect.y = player.y;
;
	lda     _player
	sta     _player_rect+1
;
; stick_rect.x  = stick.x;
;
	lda     _stick+3
	sta     _stick_rect
;
; stick_rect.y  = stick.y;
;
	lda     _stick
	sta     _stick_rect+1
;
; player_rect.w = SPRITE_WIDTH;
;
	lda     #$08
	sta     _player_rect+2
;
; stick_rect.w  = SPRITE_WIDTH;
;
	sta     _stick_rect+2
;
; player_rect.h = SPRITE_HEIGHT;
;
	sta     _player_rect+3
;
; stick_rect.h  = SPRITE_HEIGHT;
;
	sta     _stick_rect+3
;
; points.digits[0] = 0;
;
	lda     #$00
	sta     _points
;
; points.digits[1] = 0;
;
	sta     _points+1
;
; points.digits[2] = 0;
;
	sta     _points+2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update: near

.segment	"CODE"

;
; pad = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad
;
; if ((pad & BUTTON_UP) &&
;
	and     #$08
	beq     L0139
;
; player.y > MIN_Y + SPRITE_HEIGHT)
;
	lda     _player
	cmp     #$11
	bcc     L0139
;
; --player.y;
;
	dec     _player
;
; if ((pad & BUTTON_DOWN) &&
;
L0139:	lda     _pad
	and     #$04
	beq     L013D
;
; player.y < MAX_Y - (SPRITE_HEIGHT * 2))
;
	lda     _player
	cmp     #$D7
	bcs     L013D
;
; ++player.y;
;
	inc     _player
;
; if ((pad & BUTTON_LEFT) &&
;
L013D:	lda     _pad
	and     #$02
	beq     L0141
;
; player.x > MIN_X + SPRITE_WIDTH)
;
	lda     _player+3
	cmp     #$09
	bcc     L0141
;
; --player.x;
;
	dec     _player+3
;
; if ((pad & BUTTON_RIGHT) &&
;
L0141:	lda     _pad
	and     #$01
	beq     L0145
;
; player.x < MAX_X - (SPRITE_WIDTH * 2))
;
	lda     _player+3
	cmp     #$F0
	bcs     L0145
;
; ++player.x;
;
	inc     _player+3
;
; player_rect.x = player.x;
;
L0145:	lda     _player+3
	sta     _player_rect
;
; player_rect.y = player.y;
;
	lda     _player
	sta     _player_rect+1
;
; player_rect.max_x = player_rect.x + player_rect.w;
;
	lda     _player_rect
	clc
	adc     _player_rect+2
	sta     _player_rect+4
;
; player_rect.max_y = player_rect.y + player_rect.h;
;
	lda     _player_rect+1
	clc
	adc     _player_rect+3
	sta     _player_rect+5
;
; stick_rect.x  = stick.x;
;
	lda     _stick+3
	sta     _stick_rect
;
; stick_rect.y  = stick.y;
;
	lda     _stick
	sta     _stick_rect+1
;
; stick_rect.max_x = stick_rect.x + stick_rect.w;
;
	lda     _stick_rect
	clc
	adc     _stick_rect+2
	sta     _stick_rect+4
;
; stick_rect.max_y = stick_rect.y + stick_rect.h;
;
	lda     _stick_rect+1
	clc
	adc     _stick_rect+3
	sta     _stick_rect+5
;
; colliding = (player_rect.x < stick_rect.max_x) &&
;
	ldx     #$00
	lda     _player_rect
	cmp     _stick_rect+4
	txa
	bcs     L0149
;
; (player_rect.max_x > stick_rect.x) &&
;
	lda     _player_rect+4
	sec
	sbc     _stick_rect
	bcc     L0146
	beq     L0146
;
; (player_rect.y < stick_rect.max_y) &&
;
	lda     _player_rect+1
	cmp     _stick_rect+5
	txa
	bcs     L0149
;
; (player_rect.max_y > stick_rect.y);
;
	lda     _player_rect+5
	sec
	sbc     _stick_rect+1
	sta     tmp1
	lda     tmp1
	beq     L0149
	bcs     L0148
L0146:	txa
	jmp     L0149
L0148:	lda     #$01
L0149:	sta     _colliding
;
; if (colliding)
;
	lda     _colliding
	beq     L0112
;
; stick.x = rand();
;
	jsr     _rand
	sta     _stick+3
;
; stick.y = rand();
;
	jsr     _rand
	sta     _stick
;
; points.digits[0] += 1;
;
	inc     _points
;
; if (points.digits[0] > 9)
;
	lda     _points
	cmp     #$0A
	bcc     L014A
;
; points.digits[0] =  0;
;
	lda     #$00
	sta     _points
;
; points.digits[1] += 1;
;
	inc     _points+1
;
; if (points.digits[1] > 9)
;
L014A:	lda     _points+1
	cmp     #$0A
	bcc     L0112
;
; points.digits[1] =  0;
;
	lda     #$00
	sta     _points+1
;
; points.digits[2] += 1;
;
	inc     _points+2
;
; }
;
L0112:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_disable();
;
	jsr     _ppu_disable
;
; pal_bg(PALETTE);
;
	lda     #<(_PALETTE)
	ldx     #>(_PALETTE)
	jsr     _pal_bg
;
; draw_background();
;
	jsr     _draw_background
;
; init();
;
	jsr     _init
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; ppu_wait_nmi();
;
L0122:	jsr     _ppu_wait_nmi
;
; update();
;
	jsr     _update
;
; while (1)
;
	jmp     L0122

.endproc

